<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sagar Bhandari - Android Developer Portfolio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Smooth scrolling for anchor links */
        html {
            scroll-behavior: smooth;
        }
        /* Custom hover effects for project and blog cards */
        .project-card:hover, .blog-card:hover {
            transform: translateY(-5px);
            transition: transform 0.3s ease;
        }
        /* Hide full blog content by default */
        .blog-content {
            display: none;
        }
        .blog-content.active {
            display: block;
        }
        /* Circular profile photo */
        .profile-photo {
            border-radius: 50%;
            object-fit: cover;
        }
        /* Mobile menu hidden by default */
        .mobile-menu {
            display: none;
        }
        /* Show mobile menu when active */
        .mobile-menu.active {
            display: block;
        }
    </style>
</head>
<body class="bg-gray-100 font-sans text-gray-800">
    <!-- Navigation Bar -->
    <nav class="bg-cyan-50 text-gray-800 fixed w-full top-0 z-10 shadow-md">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4 flex justify-between items-center">
            <div class="text-2xl font-bold">Sagar Bhandari</div>
            <!-- Desktop Menu -->
            <ul class="hidden md:flex space-x-6">
                <li><a href="#home" class="hover:text-cyan-600">Home</a></li>
                <li><a href="#about" class="hover:text-cyan-600">About</a></li>
                <li><a href="#experience" class="hover:text-cyan-600">Experience</a></li>
                <li><a href="#projects" class="hover:text-cyan-600">Projects</a></li>
                <li><a href="#education" class="hover:text-cyan-600">Education</a></li>
                <li><a href="#skills" class="hover:text-cyan-600">Skills</a></li>
                <li><a href="#blog" class="hover:text-cyan-600">Blog</a></li>
                <li><a href="#contact" class="hover:text-cyan-600">Contact</a></li>
            </ul>
            <!-- Hamburger Icon for Mobile -->
            <button id="hamburger" class="md:hidden focus:outline-none">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
                </svg>
            </button>
        </div>
        <!-- Mobile Menu -->
        <ul id="mobile-menu" class="mobile-menu bg-cyan-50 md:hidden flex-col items-center space-y-4 py-4">
            <li><a href="#home" class="hover:text-cyan-600">Home</a></li>
            <li><a href="#about" class="hover:text-cyan-600">About</a></li>
            <li><a href="#experience" class="hover:text-cyan-600">Experience</a></li>
            <li><a href="#projects" class="hover:text-cyan-600">Projects</a></li>
            <li><a href="#education" class="hover:text-cyan-600">Education</a></li>
            <li><a href="#skills" class="hover:text-cyan-600">Skills</a></li>
            <li><a href="#blog" class="hover:text-cyan-600">Blog</a></li>
            <li><a href="#contact" class="hover:text-cyan-600">Contact</a></li>
        </ul>
    </nav>

    <!-- Hero Section -->
    <section id="home" class="min-h-screen flex items-center justify-center bg-gradient-to-r from-cyan-50 to-white text-gray-800 pt-20">
        <div class="text-center px-4">
            <img src="https://via.placeholder.com/150" alt="Sagar Bhandari Profile Photo" class="profile-photo w-24 h-24 sm:w-32 sm:h-32 mx-auto mb-4">
            <h1 class="text-4xl sm:text-5xl font-bold mb-4">Sagar Bhandari</h1>
            <p class="text-xl sm:text-2xl mb-6">Senior Android Developer</p>
            <p class="text-base sm:text-lg max-w-2xl mx-auto">Building high-performance financial applications with over 5 years of expertise in Java, Kotlin, and Android SDK.</p>
            <a href="#contact" class="mt-6 inline-block bg-cyan-600 text-white px-6 py-3 rounded-lg font-semibold hover:bg-cyan-700">Get in Touch</a>
        </div>
    </section>

    <!-- About Section -->
    <section id="about" class="py-12 bg-white">
        <div class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8">
            <h2 class="text-2xl sm:text-3xl font-semibold mb-6 text-center">About Me</h2>
            <p class="text-base sm:text-lg text-center">
                Senior Android Developer with over 5 years of experience in developing high-performance financial applications. Proficient in Java and Kotlin, with expertise in Android SDK, Jetpack, and security frameworks. Skilled in leading teams, optimizing performance, and implementing best practices. Proven ability to translate business requirements into technical solutions, driving innovation and enhancing user experience.
            </p>
        </div>
    </section>

    <!-- Experience Section -->
    <section id="experience" class="py-12 bg-gray-100">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <h2 class="text-2xl sm:text-3xl font-semibold mb-6 text-center">Professional Experience</h2>
            <div class="space-y-6">
                <div class="bg-white p-4 sm:p-6 rounded-lg shadow-md">
                    <h3 class="text-lg sm:text-xl font-semibold">Senior Android Developer</h3>
                    <p class="text-gray-600">Synergistic Financial Network PVT. LTD. (Acquired by PINLAB), Mumbai, India</p>
                    <p class="text-gray-600">June 2022 - Present</p>
                    <ul class="list-disc ml-6 mt-4 space-y-2 text-sm sm:text-base">
                        <li>Led development and maintenance of critical Android applications for financial services, ensuring scalability and security.</li>
                        <li>Collaborated with cross-functional teams to define requirements and implement new features.</li>
                        <li>Mentored junior developers, fostering knowledge sharing and continuous learning.</li>
                        <li>Implemented best practices in code architecture, performance optimization, and unit testing.</li>
                        <li>Conducted code reviews and contributed to continuous improvement initiatives.</li>
                    </ul>
                </div>
                <div class="bg-white p-4 sm:p-6 rounded-lg shadow-md">
                    <h3 class="text-lg sm:text-xl font-semibold">Android Developer</h3>
                    <p class="text-gray-600">Brontoo Technology Financial Network PVT, Mumbai, India</p>
                    <p class="text-gray-600">May 2019 - May 2022</p>
                    <ul class="list-disc ml-6 mt-4 space-y-2 text-sm sm:text-base">
                        <li>Designed and developed Android applications for financial services, focusing on performance and stability.</li>
                        <li>Collaborated with product managers to gather requirements and translate them into technical solutions.</li>
                        <li>Integrated payment gateways to facilitate secure transactions.</li>
                        <li>Conducted thorough testing and debugging to ensure high-quality deliverables.</li>
                        <li>Researched and adopted emerging technologies to improve development processes.</li>
                    </ul>
                </div>
            </div>
        </div>
    </section>

    <!-- Projects Section -->
    <section id="projects" class="py-12 bg-white">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <h2 class="text-2xl sm:text-3xl font-semibold mb-6 text-center">Projects</h2>
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                <div class="project-card bg-gray-100 p-4 rounded-lg shadow-md">
                    <h3 class="text-base sm:text-lg font-semibold">Osta Banking App</h3>
                    <p class="text-gray-600 text-sm sm:text-base">Developed an application with over 5,000 downloads, featuring two-factor authentication and encrypted data transmission.</p>
                </div>
                <div class="project-card bg-gray-100 p-4 rounded-lg shadow-md">
                    <h3 class="text-base sm:text-lg font-semibold">Bank SDK (Payment Solutions)</h3>
                    <p class="text-gray-600 text-sm sm:text-base">Created a Bank SDK for CEAGE Technology and Central Bank of India, integrated into over 50 banks with features like BillPay and Fastag.</p>
                </div>
                <div class="project-card bg-gray-100 p-4 rounded-lg shadow-md">
                    <h3 class="text-base sm:text-lg font-semibold">Payment Gateway SDK</h3>
                    <p class="text-gray-600 text-sm sm:text-base">Developed an intermediary SDK for seamless and secure payments between clients and payment gateways.</p>
                </div>
                <div class="project-card bg-gray-100 p-4 rounded-lg shadow-md">
                    <h3 class="text-base sm:text-lg font-semibold">Mosambee Application</h3>
                    <p class="text-gray-600 text-sm sm:text-base">Contributed to an app with over 500,000 downloads, focusing on POS terminal integration and feature enhancements.</p>
                </div>
                <div class="project-card bg-gray-100 p-4 rounded-lg shadow-md">
                    <h3 class="text-base sm:text-lg font-semibold">Mosambee SDK</h3>
                    <p class="text-gray-600 text-sm sm:text-base">Developed a POS solution SDK, coordinating with merchants to resolve issues and add features.</p>
                </div>
                <div class="project-card bg-gray-100 p-4 rounded-lg shadow-md">
                    <h3 class="text-base sm:text-lg font-semibold">Central Railway Fine Pay Application</h3>
                    <p class="text-gray-600 text-sm sm:text-base">Built a payment solution for ticket collectors on POS terminals with secure payment gateways.</p>
                </div>
                <div class="project-card bg-gray-100 p-4 rounded-lg shadow-md">
                    <h3 class="text-base sm:text-lg font-semibold">RKI Application</h3>
                    <p class="text-gray-600 text-sm sm:text-base">Developed a mobile app for secure key injection into payment terminals using Java/Kotlin and robust encryption.</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Education Section -->
    <section id="education" class="py-12 bg-gray-100">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <h2 class="text-2xl sm:text-3xl font-semibold mb-6 text-center">Education</h2>
            <div class="space-y-4">
                <div class="bg-white p-4 sm:p-6 rounded-lg shadow-md">
                    <h3 class="text-lg sm:text-xl font-semibold">Bachelor of Engineering in Computer Engineering</h3>
                    <p class="text-gray-600 text-sm sm:text-base">Vidyalankar Institute of Technology, Mumbai University</p>
                    <p class="text-gray-600 text-sm sm:text-base">April 2016 - May 2019</p>
                    <p class="text-gray-600 text-sm sm:text-base">CGPA: 8/10</p>
                </div>
                <div class="bg-white p-4 sm:p-6 rounded-lg shadow-md">
                    <h3 class="text-lg sm:text-xl font-semibold">Diploma in Computer Engineering</h3>
                    <p class="text-gray-600 text-sm sm:text-base">Government Polytechnic Thane, Mumbai University</p>
                    <p class="text-gray-600 text-sm sm:text-base">April 2013 - May 2016</p>
                    <p class="text-gray-600 text-sm sm:text-base">Percentage: 83/100</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Skills Section -->
    <section id="skills" class="py-12 bg-white">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <h2 class="text-2xl sm:text-3xl font-semibold mb-6 text-center">Skills</h2>
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                <div class="bg-gray-100 p-4 rounded-lg">
                    <h3 class="font-semibold text-sm sm:text-base">Programming Languages</h3>
                    <p class="text-sm sm:text-base">Java, Kotlin</p>
                </div>
                <div class="bg-gray-100 p-4 rounded-lg">
                    <h3 class="font-semibold text-sm sm:text-base">Android Frameworks</h3>
                    <p class="text-sm sm:text-base">Android SDK, Android Jetpack, Retrofit, Room, JetSecurity</p>
                </div>
                <div class="bg-gray-100 p-4 rounded-lg">
                    <h3 class="font-semibold text-sm sm:text-base">UI/UX</h3>
                    <p class="text-sm sm:text-base">XML, ConstraintLayout, Material Design</p>
                </div>
                <div class="bg-gray-100 p-4 rounded-lg">
                    <h3 class="font-semibold text-sm sm:text-base">Version Control</h3>
                    <p class="text-sm sm:text-base">Git, GitHub, Gittab</p>
                </div>
                <div class="bg-gray-100 p-4 rounded-lg">
                    <h3 class="font-semibold text-sm sm:text-base">Architectural Patterns</h3>
                    <p class="text-sm sm:text-base">MVP, MVVM</p>
                </div>
                <div class="bg-gray-100 p-4 rounded-lg">
                    <h3 class="font-semibold text-sm sm:text-base">Dependency Injection</h3>
                    <p class="text-sm sm:text-base">Dagger, Hilt</p>
                </div>
                <div class="bg-gray-100 p-4 rounded-lg">
                    <h3 class="font-semibold text-sm sm:text-base">Reactive Programming</h3>
                    <p class="text-sm sm:text-base">RxJava, LiveData</p>
                </div>
                <div class="bg-gray-100 p-4 rounded-lg">
                    <h3 class="font-semibold text-sm sm:text-base">Payment Gateways</h3>
                    <p class="text-sm sm:text-base">PayPal, AggreyPay, Paytm</p>
                </div>
                <div class="bg-gray-100 p-4 rounded-lg">
                    <h3 class="font-semibold text-sm sm:text-base">Data Persistence</h3>
                    <p class="text-sm sm:text-base">SQLite, Room, Realtime Database</p>
                </div>
                <div class="bg-gray-100 p-4 rounded-lg">
                    <p class="text-sm sm:text-base">Performance Optimization, Debugging, PCI Compliance, Cryptographic Protocols</p>
                </div>
                <div class="bg-gray-100 p-4 rounded-lg">
                    <h3 class="font-semibold text-sm sm:text-base">Payment Terminals</h3>
                    <p class="text-sm sm:text-base">M919, Qpos, P10, P5, KOZEN, APOS</p>
                </div>
                <div class="bg-gray-100 p-4 rounded-lg">
                    <h3 class="font-semibold text-sm sm:text-base">Other</h3>
                    <p class="text-sm sm:text-base">Flutter (Plugin Implementation), RKI (Remote Key Injection) Terminals, EMV Application (POS Device)</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Blog Section -->
    <section id="blog" class="py-12 bg-gray-100">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <h2 class="text-2xl sm:text-3xl font-semibold mb-6 text-center">Blog</h2>
            <div class="space-y-4">
                <!-- Blog Post 1 -->
                <div class="blog-card bg-white p-4 sm:p-6 rounded-lg shadow-md cursor-pointer" onclick="toggleBlogContent('blog1')">
                    <h3 class="text-lg sm:text-xl font-semibold">Camera-Based MFA Using Sensor Imperfections</h3>
                    <p class="text-gray-600 text-xs sm:text-sm">Posted on June 23, 2025</p>
                    <p class="text-gray-600 mt-2 text-sm sm:text-base">Using smartphone camera sensor imperfections as a PUF to generate secure, device-bound passkeys for MFA.</p>
                    <div id="blog1" class="blog-content mt-4 text-gray-700 text-sm sm:text-base">
                        <p>In the evolving landscape of digital security, leveraging smartphone hardware for Multi-Factor Authentication (MFA) offers a robust solution. This blog explores a novel approach that uses a smartphone’s camera sensor imperfections as a Physical Unclonable Function (PUF) to generate secure, device-bound passkeys. Below is a step-by-step technical breakdown, a flowchart, and sample SDK code to illustrate the implementation, showcasing its potential in modern authentication systems.</p>
                        <h4 class="text-base sm:text-lg font-semibold mt-4">Step-by-Step Process</h4>
                        <h5 class="text-sm sm:text-base font-semibold mt-2">1. Capture Raw Sensor Data</h5>
                        <p>The process begins by accessing the smartphone’s camera via the Camera2 API to capture a RAW_SENSOR image (DNG format). To isolate sensor noise, the capture occurs with the lens covered, using low ISO (e.g., 100) and short exposure (e.g., 1ms). This minimizes external light interference, highlighting the sensor’s unique imperfections caused by manufacturing variations in the silicon wafer.</p>
                        <h5 class="text-sm sm:text-base font-semibold mt-2">2. Extract Noise Patterns</h5>
                        <p>Using OpenCV, the raw image is converted to a grayscale matrix (e.g., via COLOR_BayerRG2GRAY demosaicing). A high-pass filter, such as a Laplacian, isolates high-frequency noise components. These noise patterns, unique to each sensor, are quantized into a binary fingerprint (e.g., 256 bits) by thresholding pixel values against the mean noise level.</p>
                        <h5 class="text-sm sm:text-base font-semibold mt-2">3. Generate and Obfuscate Private Key</h5>
                        <p>An elliptic curve (EC) key pair is generated using the Android Keystore with the secp256r1 curve. The private key is encrypted (obfuscated) using the sensor fingerprint as an AES key. The obfuscated key is stored securely in the Keystore, ensuring it’s only accessible when the correct fingerprint is provided.</p>
                        <h5 class="text-sm sm:text-base font-semibold mt-2">4. Authenticate Using Sensor Fingerprint</h5>
                        <p>During authentication, the app recaptures the sensor fingerprint and compares it to the stored reference. If they match, the fingerprint de-obfuscates the private key, which signs a server challenge (e.g., using SHA256withECDSA). The server verifies the signature with the public key, confirming device possession.</p>
                        <h5 class="text-sm sm:text-base font-semibold mt-2">5. Enhance with TEE or Whitebox Cryptography</h5>
                        <p>For added security, key operations can occur in a Trusted Execution Environment (TEE) if available. Alternatively, whitebox cryptography protects the key on devices without TEE, ensuring resilience against malware or device compromise.</p>
                        <h4 class="text-base sm:text-lg font-semibold mt-4">Process Flow Diagram</h4>
                        <p>Below is a flowchart illustrating the camera-based MFA process, making it easier to visualize the steps:</p>
                        <img src="./blog_Camera_Based_MFA_Using_Sensor_Imperfections.png" alt="Camera-Based MFA Flow Diagram" class="w-full max-w-2xl mx-auto my-4">
                        
                        <h4 class="text-base sm:text-lg font-semibold mt-4">Sample Code</h4>
                        <p>Below is a simplified Kotlin implementation of the MFA SDK, focusing on capturing the camera sensor fingerprint and performing authentication. This code demonstrates how the steps above are translated into a practical Android solution.</p>
                        <pre class="bg-gray-800 text-white p-4 rounded text-xs sm:text-sm"><code>package com.example.mfa

import android.content.Context
import android.hardware.camera2.*
import android.media.ImageReader
import android.os.Build
import android.os.Handler
import android.os.HandlerThread
import android.util.Base64
import androidx.annotation.RequiresApi
import org.opencv.android.OpenCVLoader
import org.opencv.core.CvType
import org.opencv.core.Mat
import org.opencv.imgproc.Imgproc
import java.nio.ByteBuffer
import java.security.KeyPairGenerator
import java.security.KeyStore
import javax.crypto.Cipher
import javax.crypto.spec.SecretKeySpec
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException
import kotlin.coroutines.suspendCoroutine

class MFASDK(private val context: Context) {

    private val keyStore = KeyStore.getInstance("AndroidKeyStore").apply { load(null) }
    private val keyAlias = "MFAKey"
    private val cameraManager = context.getSystemService(Context.CAMERA_SERVICE) as CameraManager
    private val handlerThread = HandlerThread("MFACameraThread").apply { start() }
    private val handler = Handler(handlerThread.looper)
    private var sensorFingerprint: ByteArray? = null

    init {
        if (!OpenCVLoader.initDebug()) throw IllegalStateException("OpenCV initialization failed")
    }

    @RequiresApi(Build.VERSION_CODES.M)
    suspend fun initialize(): Result<Unit> = suspendCoroutine { continuation ->
        try {
            if (!keyStore.containsAlias(keyAlias)) {
                // Generate EC key pair
                val keyPairGenerator = KeyPairGenerator.getInstance("EC", "AndroidKeyStore")
                keyPairGenerator.initialize(
                    KeyGenParameterSpec.Builder(
                        keyAlias,
                        KeyProperties.PURPOSE_SIGN or KeyProperties.PURPOSE_VERIFY
                    ).setDigests(KeyProperties.DIGEST_SHA256)
                        .setAlgorithmParameterSpec(java.security.spec.ECGenParameterSpec("secp256r1"))
                        .build()
                )
                val keyPair = keyPairGenerator.generateKeyPair()
                captureSensorFingerprint { result ->
                    result.onSuccess { fingerprint ->
                        sensorFingerprint = fingerprint
                        // Obfuscate private key with fingerprint
                        val cipher = Cipher.getInstance("AES/ECB/PKCS5Padding")
                        val secretKey = SecretKeySpec(fingerprint.copyOf(16), "AES")
                        cipher.init(Cipher.ENCRYPT_MODE, secretKey)
                        val obfuscatedKey = cipher.doFinal(keyPair.private.encoded)
                        keyStore.setEntry(
                            "$keyAlias-obfuscated",
                            KeyStore.SecretKeyEntry(SecretKeySpec(obfuscatedKey, "AES")),
                            null
                        )
                        continuation.resume(Result.success(Unit))
                    }.onFailure { continuation.resumeWithException(it) }
                }
            } else {
                continuation.resume(Result.success(Unit))
            }
        } catch (e: Exception) {
            continuation.resumeWithException(e)
        }
    }

    @RequiresApi(Build.VERSION_CODES.M)
    private fun captureSensorFingerprint(callback: (Result<ByteArray>) -> Unit) {
        try {
            val cameraId = cameraManager.cameraIdList.first()
            cameraManager.openCamera(cameraId, object : CameraDevice.StateCallback() {
                override fun onOpened(camera: CameraDevice) {
                    val imageReader = ImageReader.newInstance(640, 480, ImageFormat.RAW_SENSOR, 1)
                    val captureSessionCallback = object : CameraCaptureSession.StateCallback() {
                        override fun onConfigured(session: CameraCaptureSession) {
                            val builder = camera.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE)
                            builder.addTarget(imageReader.surface)
                            builder.set(CaptureRequest.CONTROL_AE_MODE, CaptureRequest.CONTROL_AE_MODE_OFF)
                            builder.set(CaptureRequest.SENSOR_SENSITIVITY, 100) // Low ISO
                            builder.set(CaptureRequest.SENSOR_EXPOSURE_TIME, 1000000L) // 1ms
                            imageReader.setOnImageAvailableListener({ reader ->
                                val image = reader.acquireNextImage()
                                val fingerprint = processRawImage(image)
                                image.close()
                                reader.close()
                                session.close()
                                camera.close()
                                callback(Result.success(fingerprint))
                            }, handler)
                            session.capture(builder.build(), null, handler)
                        }
                        override fun onConfigureFailed(session: CameraCaptureSession) {
                            session.close()
                            camera.close()
                            callback(Result.failure(Exception("Camera configuration failed")))
                        }
                    }
                    camera.createCaptureSession(listOf(imageReader.surface), captureSessionCallback, handler)
                }
                override fun onDisconnected(camera: CameraDevice) {
                    camera.close()
                    callback(Result.failure(Exception("Camera disconnected")))
                }
                override fun onError(camera: CameraDevice, error: Int) {
                    camera.close()
                    callback(Result.failure(Exception("Camera error: $error")))
                }
            }, handler)
        } catch (e: Exception) {
            callback(Result.failure(e))
        }
    }

    private fun processRawImage(image: android.media.Image): ByteArray {
        // Extract raw data
        val buffer: ByteBuffer = image.planes[0].buffer
        val rawData = ByteArray(buffer.remaining())
        buffer.get(rawData)

        // Process with OpenCV
        val rawMat = Mat(image.height, image.width, CvType.CV_16U)
        rawMat.put(0, 0, rawData)
        val grayMat = Mat()
        Imgproc.cvtColor(rawMat, grayMat, Imgproc.COLOR_BayerRG2GRAY)
        val noiseMat = Mat()
        Imgproc.Laplacian(grayMat, noiseMat, CvType.CV_16S, 3)

        // Quantize to 256-bit fingerprint
        val fingerprint = ByteArray(32)
        val noiseData = DoubleArray(noiseMat.total().toInt())
        noiseMat.get(0, 0, noiseData)
        val threshold = noiseData.average()
        for (i in 0 until 32) {
            var byte = 0
            for (j in 0 until 8) {
                val index = (i * 8 + j) % noiseData.size
                byte = byte or (if (noiseData[index] > threshold) 1 else 0 shl (7 - j))
            }
            fingerprint[i] = byte.toByte()
        }

        rawMat.release()
        grayMat.release()
        noiseMat.release()
        return fingerprint
    }

    @RequiresApi(Build.VERSION_CODES.M)
    suspend fun authenticate(challenge: String): Result<String> = suspendCoroutine { continuation ->
        captureSensorFingerprint { result ->
            result.onSuccess { fingerprint ->
                if (!sensorFingerprint.contentEquals(fingerprint)) {
                    continuation.resumeWithException(SecurityException("Fingerprint mismatch"))
                    return@captureSensorFingerprint
                }
                // De-obfuscate key and sign challenge
                val obfuscatedKeyEntry = keyStore.getEntry("$keyAlias-obfuscated", null) as KeyStore.SecretKeyEntry
                val cipher = Cipher.getInstance("AES/ECB/PKCS5Padding")
                val secretKey = SecretKeySpec(fingerprint.copyOf(16), "AES")
                cipher.init(Cipher.DECRYPT_MODE, secretKey)
                val privateKeyBytes = cipher.doFinal(obfuscatedKeyEntry.secretKey.encoded)
                val keyFactory = java.security.KeyFactory.getInstance("EC")
                val privateKey = keyFactory.generatePrivate(java.security.spec.PKCS8EncodedKeySpec(privateKeyBytes))
                val signature = java.security.Signature.getInstance("SHA256withECDSA").apply {
                    initSign(privateKey)
                    update(challenge.toByteArray())
                }.sign()
                continuation.resume(Result.success(Base64.encodeToString(signature, Base64.DEFAULT)))
            }.onFailure { continuation.resumeWithException(it) }
        }
    }

    fun release() {
        handlerThread.quitSafely()
    }
}</code></pre>
                        <h4 class="text-base sm:text-lg font-semibold mt-4">Code Explanation</h4>
                        <ul class="list-disc ml-6 space-y-2">
                            <li><strong>Initialization:</strong> Generates an EC key pair and captures the initial sensor fingerprint to obfuscate the private key using AES.</li>
                            <li><strong>Fingerprint Capture:</strong> Uses Camera2 API to capture a raw image with low ISO, processes it with OpenCV to extract noise, and quantizes it into a 256-bit fingerprint.</li>
                            <li><strong>Authentication:</strong> Recaptures the fingerprint, verifies it, de-obfuscates the private key, and signs a server challenge.</li>
                            <li><strong>Dependencies:</strong> Requires <code>androidx.camera:camera-camera2</code> and <code>org.opencv:opencv</code>.</li>
                        </ul>
                        <p>To use this SDK, add camera permissions (<code>&lt;uses-permission android:name="android.permission.CAMERA" /&gt;</code>) and dependencies in your Android project. The full implementation would include TEE support and fuzzy extractors for production use.</p>
                        <h4 class="text-base sm:text-lg font-semibold mt-4">Technical Advantages</h4>
                        <ul class="list-disc ml-6 space-y-2">
                            <li><strong>Unclonable Security:</strong> The sensor’s PUF ensures keys are device-bound, resisting cloning even if the device is fully compromised.</li>
                            <li><strong>Usability:</strong> The process is seamless, requiring only a momentary camera capture without user interaction.</li>
                            <li><strong>Cost-Effective:</strong> Leverages existing smartphone hardware, eliminating the need for dedicated tokens.</li>
                            <li><strong>Compliance:</strong> Aligns with FIDO, PSD2, and SCA standards for strong authentication.</li>
                        </ul>
                        <p>This project demonstrates my expertise in integrating hardware-based cryptography and image processing into secure mobile applications, paving the way for next-generation MFA solutions.</p>
                        <p>Explore more of my work on advanced authentication in my <a href="#projects" class="text-cyan-600 hover:underline">portfolio</a> or reach out via the <a href="#contact" class="text-cyan-600 hover:underline">Contact</a> section!</p>
                    </div>
                </div>
                <!-- Blog Post 2 -->
                <div class="blog-card bg-white p-4 sm:p-6 rounded-lg shadow-md cursor-pointer" onclick="toggleBlogContent('blog2')">
                    <h3 class="text-lg sm:text-xl font-semibold">Optimizing Android App Performance with Jetpack Compose</h3>
                    <p class="text-gray-600 text-xs sm:text-sm">Posted on December 23, 2024</p>
                    <p class="text-gray-600 mt-2 text-sm sm:text-base">Leveraging Jetpack Compose to enhance UI performance and reduce memory usage in Android applications.</p>
                    <div id="blog2" class="blog-content mt-4 text-gray-700 text-sm sm:text-base">
                        <h4 class="text-base sm:text-lg font-semibold">Introduction</h4>
                        <p>Jetpack Compose, Android’s modern UI toolkit, has transformed the way developers build user interfaces. In my work on financial apps like the Osta Banking App, I’ve used Compose to optimize performance, reduce memory usage, and streamline development. This post explores key techniques to maximize Compose’s potential for high-performance Android apps.</p>
                        <h4 class="text-base sm:text-lg font-semibold mt-4">Why Jetpack Compose?</h4>
                        <p>Unlike traditional XML layouts, Compose uses a declarative approach, reducing boilerplate and enabling faster UI updates. Its recomposition mechanism ensures only modified UI components are redrawn, improving performance.</p>
                        <h4 class="text-base sm:text-lg font-semibold mt-4">Optimizing Recomposition</h4>
                        <p>To minimize unnecessary recompositions, use these strategies:</p>
                        <ul class="list-disc ml-6 space-y-2">
                            <li>Use <code>remember</code> to cache expensive objects across recompositions.</li>
                            <li>Avoid complex computations in composables; move them to ViewModels.</li>
                            <li>Leverage <code>derivedStateOf</code> for state transformations.</li>
                        </ul>
                        <p>Example:</p>
                        <pre class="bg-gray-800 text-white p-4 rounded text-xs sm:text-sm"><code>@Composable
fun UserProfile(name: String) {
    val greeting = remember { "Hello, $name!" }
    Text(text = greeting, style = MaterialTheme.typography.h6)
}</code></pre>
                        <h4 class="text-base sm:text-lg font-semibold mt-4">Reducing Memory Usage</h4>
                        <p>Compose’s stateless nature helps, but you can further optimize by:</p>
                        <ul class="list-disc ml-6 space-y-2">
                            <li>Using <code>LazyColumn</code> or <code>LazyRow</code> for large lists to load items on-demand.</li>
                            <li>Avoiding over-nesting composables, which can increase memory overhead.</li>
                        </ul>
                        <p>Example with <code>LazyColumn</code>:</p>
                        <pre class="bg-gray-800 text-white p-4 rounded text-xs sm:text-sm"><code>@Composable
fun TransactionList(transactions: List<Transaction>) {
    LazyColumn {
        items(transactions) { transaction ->
            Text(text = transaction.description)
        }
    }
}</code></pre>
                        <h4 class="text-base sm:text-lg font-semibold mt-4">Performance Tools</h4>
                        <p>Use Android Studio’s API and Profiler to identify recomposition bottlenecks. For example, I reduced frame drops in the Mosambee app by optimizing a payment screen’s recomposition rate by 30%.</p>
                        <h4 class="text-base sm:text-lg font-semibold mt-4">Conclusion</h4>
                        <p>Jetpack Compose offers powerful tools for building performant UIs. By optimizing recomposition and leveraging lazy loading, developers can create smooth, memory-efficient apps. For more insights or sample code, reach out via the <a href="#contact" class="text-cyan-600 hover:underline">Contact</a> section!</p>
                    </div>
                </div>
                <!-- Blog Post 3 -->
                <div class="blog-card bg-white p-4 sm:p-6-lg shadow-md cursor-pointer" onclick="toggleBlogContent('blog3')">
                    <h3 class="text-lg sm:text-xl font-semibold">Implementing Secure API Authentication in Android</h4>
                    <p class="text-gray-600 text-xs sm:text-sm">Posted on December 23, 2024</p>
                    <p class="text-gray-600 mt-2 text-sm sm:text-base">Securing Android apps with OAuth 2.0 and JWT for robust API authentication.</p>
                    <div id="blog3" class="blog-content mt-4 text-gray-700 text-sm sm:text-base">
                        <h4 class="text-base sm:text-lg font-semibold">Introduction</h4>
                        <p>Secure API authentication is critical for financial apps like the Osta Banking App and Payment Gateway SDK. This post covers implementing OAuth 2.0 and JWT-based authentication in Android to protect sensitive data and ensure secure communication with APIs.</p>
                        <h4 class="text-base sm:text-lg font-semibold mt-4">OAuth 2.0 Setup</h4>
                        <p>Use the <a href="https://github.com/openid/AppAuth-Android" class="text-cyan-600 hover:underline">AppAuth</a> library for OAuth 2.0. Configure it to handle authorization code flow:</p>
                        </pre>
                        <p>Store tokens securely using JetSecurity’s EncryptedSharedPreferences.</p>
                        <h4 class="text-base sm:text-base font-semibold mt-4">JWT Integration</h4>
                        <p>Use a library like <code>jjwt</code> to parse and validate JWTs:</p>
                        <pre class="bg-gray-800 text-white p-4 rounded text-xs sm:text-sm"><code>implementation "io.jsonwebtoken:jjwt:0.9.1"

fun validateJwt(token: String, secret: String): Claims {
    return Jwts.parser().setSigningKey(secret).parseClaimsJws(token).body
}</code></pre>
                        <p>Validate the token’s signature and expiry before making API calls.</p>
                        <h4 class="text-base sm:text-lg font-semibold mt-4">Best Practices</h4>
                        <ul class="list-disc ml-6 space-y-2">
                            <li>Refresh tokens periodically to maintain session security.</li>
                            <li>Use HTTPS with certificate pinning to prevent man-in-the-middle attacks.</li>
                            <li>Implement token revocation on logout.</li>
                        </ul>
                        <h4 class="text-base sm:text-lg font-semibold mt-4">Conclusion</h4>
                        <p>Combining OAuth 2.0 with JWT ensures robust API authentication. In my projects, this approach reduced unauthorized access incidents by 40%. For implementation details, contact me via the <a href="#contact" class="text-cyan-600 hover:underline">Contact</a> section!</p>
                    </div>
                </div>
                <!-- Blog Post 4 -->
                <div class="blog-card bg-white p-4 sm:p-6 rounded-lg shadow-md cursor-pointer" onclick="toggleBlogContent('blog4')">
                    <h3 class="text-lg sm:text-xl font-semibold">Building a Custom AppSealing-Like APK Protection System</h3>
                    <p class="text-gray-600 text-xs sm:text-sm">Posted on December 23, 2024</p>
                    <p class="text-gray-600 mt-2 text-sm sm:text-base">A guide to creating a custom APK protection system with DEX encryption, native anti-debug checks, and dynamic loading.</p>
                    <div id="blog4" class="blog-content mt-4 text-gray-700 text-sm sm:text-base">
                        <h4 class="text-base sm:text-lg font-semibold">Introduction</h4>
                        <p>In today’s mobile app landscape, protecting intellectual property and securing sensitive code against reverse engineering is crucial. Commercial solutions like AppSealing provide strong runtime protection and obfuscation, but what if you want to build your own free, custom protection system?</p>
                        <p>This blog walks you through building an application AppSealing-style APK protector from scratch, featuring DEX encryption, native anti-tamper debugging checks, and dynamic loading.</p>
                        <h4 class="text-base sm:text-lg font-semibold mt-4">Goals</h4>
                        <ul class="list-disc ml-6 space-y-2">
                            <li>Obfuscate Java bytecode</li>
                            <li>Encrypt classes.dex to prevent static analysis</li>
                            <li>Load encrypted DEX at runtime using native code</li>
                            <li>Detect root, debugger, and Frida</li>
                            <li>Verify APK integrity to prevent tampering</li>
                        </ul>
                        <h4 class="text-base sm:text-lg font-semibold mt-4">Phase 1: Basic Obfuscation</h4>
                        <p>We begin by obfuscating our app using <a href="https://github.com/Guardsquare/proguard" class="text-cyan-600 hover:underline">ProGuard</a> or a similar free tool like Allatori alternatives.</p>
                        <p><strong>Sample ProGuard Rules:</strong></p>
                        <pre class="bg-gray-800 text-white p-4 rounded text-xs sm:text-sm"><code>-keep public class * {
    public static void main(java.lang.String[]);
}
-renamesourcefileattribute SourceFile
-keepattributes SourceFile,LineNumberTable
-allowaccessmodification
-overloadaggressively
-dontpreverify</code></pre>
                        <p>Convert the obfuscated <code>.jar</code> to <code>.dex</code> using <code>d8</code>:</p>
<pre class="bg-gray-800 text-white p-4 rounded text-xs sm:text-sm"><code>d8 your-obfuscated.jar --output=.</code></pre>
                        <h4 class="text-base sm:text-lg font-semibold mt-4">Phase 2: Encrypting the DEX</h4>
                        <p>The core protection comes from encrypting the <code>classes.dex</code> and loading it dynamically.</p>
                        <p><strong>Python AES Encryptor:</strong></p>
                        <pre class="bg-gray-800 text-white p-4 rounded text-xs sm:text-sm"><code>from Crypto.Cipher import AES
key = b'your16byteaeskey'
iv = b'16byteinitvector'

def pad(data):
    return data + (16 - len(data) % 16) * bytes([16 - len(data) % 16])

with open('classes.dex', 'rb') as f:
    raw = f.read()

cipher = AES.new(key, AES.MODE_CBC, iv)
enc = cipher.encrypt(pad(raw))

with open('encrypted.dex', 'wb') as f:
    f.write(enc)</code></pre>
                        <h4 class="text-base sm:text-lg font-semibold mt-4">Phase 3: Loader APK</h4>
                        <p>Create a lightweight launcher app that loads the encrypted dex at runtime.</p>
                        <p><strong>Java: NativeLoader.java</strong></p>
                        <pre class="bg-gray-800 text-white p-4 rounded text-xs sm:text-sm"><code>public class NativeLoader {
    public static native byte[] decrypt(byte[] encrypted);

    public static void loadEncryptedDex(Context context) {
        // Load encrypted.dex from assets, decrypt using JNI, write to disk, load via DexClassLoader
    }
}</code></pre>
                        <h4 class="text-base sm:text-lg font-semibold mt-4">Phase 4: Native Decryption (JNI)</h4>
                        <p>Using C++, decrypt the encrypted DEX with AES at runtime.</p>
                        <p><strong>C++ (loader.cpp)</strong></p>
                        <pre class="bg-gray-800 text-white p-4 rounded text-xs sm:text-sm"><code>extern "C" JNIEXPORT jbyteArray JNICALL
Java_com_protect_loaderapp_NativeLoader_decrypt(JNIEnv *env, jclass clazz, jbyteArray encrypted) {
    // Perform AES decryption
    // Return decrypted byte[] to Java
}</code></pre>
                        <p>You can use OpenSSL or a lightweight AES library.</p>
                        <h4 class="text-base sm:text-lg font-semibold mt-4">Phase 5: Anti-Debug and Anti-Frida</h4>
                        <p>Embed anti-debugging logic in your native code:</p>
                        <p><strong>Example (anti_debug.cpp)</strong></p>
                        <pre class="bg-gray-800 text-white p-4 rounded text-xs sm:text-sm"><code>bool is_debugger_attached() {
    std::ifstream status("/proc/self/status");
    std::string line;
    while (getline(status, line)) {
        if (line.find("TracerPid:") != std::string::npos) {
            return line.back() != '0';
        }
    }
    return false;
}</code></pre>
                        <p>Also check for Frida's named pipes, Magisk files, or root binaries.</p>
                        <h4 class="text-base sm:text-lg font-semibold mt-4">Phase 6: Rebuild and Sign APK</h4>
                        <p>Use <code>apktool</code> to repack the loader APK:</p>
                        <pre class="bg-gray-800 text-white p-4 rounded text-xs sm:text-sm"><code>apktool b base-dir -o unsigned.apk
jarsigner -keystore debug.keystore -storepass android -signedjar final.apk unsigned.apk androiddebugkey</code></pre>
                        <p>You can also use <code>zipalign</code> for final optimization.</p>
                        <h4 class="text-base sm:text-lg font-semibold mt-4">Conclusion</h4>
                        <p>This custom protection system makes it significantly harder for reverse engineers to statically or dynamically analyze your app. While not as advanced as commercial obfuscators, it provides:</p>
                        <ul class="list-disc ml-6 space-y-2">
                            <li>Code concealment via encryption</li>
                            <li>Dynamic runtime loading</li>
                            <li>Native anti-debug and anti-Frida</li>
                        </ul>
                        <p>For apps with high-security requirements, you can extend this system by:</p>
                        <ul class="list-disc ml-6 space-y-2">
                            <li>Obfuscating native code (using LLVM or Tigress)</li>
                            <li>Using VM-based protection</li>
                            <li>Adding polymorphic loader behavior</li>
                        </ul>
                        <p>Security through obscurity is not enough — combine this with secure architecture, minimal runtime permissions, and API hardening.</p>
                        <p><strong>Need help generating the full working project zip?</strong> Reach out via the <a href="#contact" class="text-cyan-600 hover:underline">Contact</a> section!</p>
                    </div>
                </div>
                <!-- Blog Post 5 -->
                <div class="blog-card bg-white p-4 sm:p-6 rounded-lg shadow-md cursor-pointer" onclick="toggleBlogContent('blog5')">
                    <h3 class="text-lg sm:text-xl font-semibold">Enhancing Android Security with a Custom Virtual Machine</h3>
                    <p class="text-gray-600 text-xs sm:text-sm">Posted on December 23, 2024</p>
                    <p class="text-gray-600 mt-2 text-sm sm:text-base">Exploring why executing root detection in a custom VM is more secure than traditional Java, Kotlin, or C/C++ approaches.</p>
                    <div id="blog5" class="blog-content mt-4 text-gray-700 text-sm sm:text-base">
                        <p>There are many techniques to protect sensitive code in Android, such as obfuscation or moving logic to native C/C++ code compiled to machine code. However, tools like IDA Pro, Ghidra, and Frida make it easy to reverse-engineer and hook such code with custom implementations.</p>
                        <p>In this post, I discuss why executing root detection inside a custom virtual machine (VM) is significantly more secure than running the same logic directly in Java, Kotlin, or even native C/C++ code—and what this means for tools like Frida and experienced reverse engineers.</p>
                        <h4 class="text-base sm:text-lg font-semibold mt-4">Root Detection in ART or Native</h4>
                        <p>Most apps implement root detection with simple checks, like this in Kotlin:</p>
                        <pre class="bg-gray-800 text-white p-4 rounded text-xs sm:text-sm"><code>fun isDeviceRooted(): Boolean {
    return File("/system/bin/su").exists()
}</code></pre>
                        <p>Or in C:</p>
                        <pre class="bg-gray-800 text-white p-4 rounded text-xs sm:text-sm"><code>bool isRooted() {
    return access("/system/bin/su", F_OK) == 0;
}</code></pre>
                        <p>While these might catch some rooted devices, Frida scripts can override return values, decompiled APKs reveal function names, and native .so files can be patched using tools like Ghidra or IDA Pro.</p>
                        <h4 class="text-base sm:text-lg font-semibold mt-4">Using a Custom VM</h4>
                        <p>A custom VM operates by defining a unique bytecode format and instruction sets (e.g., opcodes like CHECK_ROOT样的,HALT). Sensitive logic is written in this bytecode, not in Kotlin or Java, and executed by a custom interpreter at runtime. For example:</p>
                        <pre class="bg-gray-800 text-white p-4 rounded text-xs sm:text-sm"><code>val bytecode = byteArrayOf(0x01, 0xFF) // CHECK_ROOT, HALT
val vm = CustomVM(bytecode)
val result = vm.run()</code></pre>
                        </p>
                        <p>The actual logic, such as which files to check or APIs to call, resides within the VM’s opcode handling, not in exposed functions.</p>
                        <h4 class="text-base sm:text-lg font-semibold mt-4">Challenges with Frida</h4>
                        <p>Frida works by hooking well-known methods (e.g., <code>access</code>, <code>exists</code>, <code>System.loadLibrary</code>) or overwriting return values. For example:</p>
                        <pre class="bg-gray-800 text-white p-4 rounded text-xs sm:text-sm"><code>Interceptor.attach(Module.findExportByName(null, 'access'), {
    onEnter: function(args) {
        // intercepts root check
    }
});</code></code></pre>
                        <p>
                        <p>With a custom VM, attackers only see:</p>
                        <pre class="bg-gray-800 text-white p-4 rounded text-xs sm:text-sm">text-sm"><code>val result = MiniVM(bytecode).run()</code></pre>
                        <p>They must reverse-engineer the entire interpreter and decode opcodes like <code>0x01</code>, significantly increasing the effort required.</p>
                        </p>
                        <h4 class="text-base sm:text-lg font-semibold mt-4">Real-World Obfuscation Practices</h4>
                        <p>To further thwart attackers, you can:</p>
                        <ul class="list-disc ml-6 space-y-2">
                            <li>Encrypt the bytecode and decrypt it at runtime.</li>
                            <li>Inject dead instructions (e.g., NOOP, JUNK) to confuse disassemblers.</li>
                            <li>Use runtime mutation, where opcodes change meaning based on a session key.</li>
                        </ul>
                        <h4 class="text-base sm:text-lg font-semibold mt-4">Performance and Maintenance</h4>
                        <p>Custom VMs are less performant and harder to maintain across different architectures. However, for security-critical apps—like banking, fintech, or secure messaging—these trade-offs are justified.</p>
                        <h4 class="text-base sm:text-lg font-semibold mt-4">Thoughts</h4>
                        <p>Running root detection in ART or native code is insufficient against modern reverse-engineering tools. This Pseudo VM technique, used by malware to evade antivirus detection, is now leveraged by solutions like Google Play Integrity’s <code>libpairipcore.so</code>. A custom VM forces reverse engineers to:</p>
                        <ul class="list-disc ml-6 space-y-2">
                            <li>Reverse-engineer a new instruction set.</li>
                            <li>Dump and decode opaque bytecode.</li>
                            <li>Spend significantly more time understanding the app’s behavior.</li>
                        </ul>
                        <p>Building a lightweight VM for critical checks makes Android apps far harder to reverse, enhancing security for sensitive operations.</p>
                    </div>
                </div>
                <!-- Blog Post 6 -->
                <div class="blog-card bg-white p-4 sm:p-6 rounded-lg shadow-md cursor-pointer" onclick="toggleBlogContent('blog6')">
                    <h3 class="text-lg sm:text-xl font-semibold">Securing Android Apps with JetSecurity</h3>
                    <p class="text-gray-600 text-xs sm:text-sm">Posted on December 23, 2024</p>
                    <p class="text-gray-600 mt-2 text-sm sm:text-base">Leveraging JetSecurity for robust encryption and authentication in financial applications.</p>
                    <div id="blog6" class="blog-content mt-4 text-gray-700 text-sm sm:text-base">
                        <p>As an Android developer specializing in financial applications, ensuring robust security is paramount. In my recent projects, such as the Osta Banking App and RKI Application, I leveraged JetSecurity to implement advanced cryptographic protocols. JetSecurity, part of Android Jetpack, simplifies the integration of encryption and authentication mechanisms. For instance, I used it to secure data transmission with AES-256 encryption and implement two-factor authentication, significantly reducing vulnerabilities. My research into JetSecurity also revealed its compatibility with Payment Card Industry (PCI) compliance, making it ideal for payment-focused apps like Mosambee. To get started, ensure you include the JetSecurity library in your Gradle file and configure a Security Key Provider. This approach has proven effective in my work, enhancing both security and user trust.</p>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Contact Section -->
    <section id="contact" class="py-12 bg-cyan-50 text-gray-800">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <h2 class="text-2xl sm:text-3xl font-semibold mb-2 text-center">Contact Me</h2>
            <p class="text-center mb-6 text-sm sm:text-base">Feel free to reach out for collaboration or inquiries!</p>
            <div class="flex flex-col items-center space-y-2 text-sm sm:text-base">
                <p>Phone: <a href="tel:+919021594157" class="hover:text-cyan-600">+91 9021594157</a></p>
                <p>Email: <a href="mailto:sagarb522@gmail.com" class="hover:text-cyan-600">sagarb522@gmail.com</a></p>
                <p>GitHub: <a href="https://github.com/sagarbhandari111" target="_blank" class="text-cyan-600 hover:underline">sagarbhandari111</a></p>
                <p>Location: Thane, Mumbai, India</p>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer class="bg-gray-800 text-white py-4 text-center text-sm sm:text-base">
        <p>© 2025 Sagar Bhandari. All rights reserved.</p>
    </footer>

    <script>
        // Smooth scrolling for anchor links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                document.querySelector(this.getAttribute('href')).scrollIntoView({
                    behavior: 'smooth'
                });
                // Close mobile menu after clicking a link
                if (window.innerWidth < 768) {
                    mobileMenu.classList.remove('active');
                }
            });
        });

        // Toggle blog content visibility
        function toggleBlogContent(blogId) {
            const content = document.getElementById(blogId);
            const isActive = content.classList.contains('active');
            // Hide all blog contents
            document.querySelectorAll('.blog-content').forEach(item => {
                item.classList.remove('active');
            });
            // Show the clicked blog content if it wasn't already active
            if (!isActive) {
                content.classList.add('active');
            }
        }

        // Hamburger menu toggle
        const hamburger = document.getElementById('hamburger');
        const mobileMenu = document.getElementById('mobile-menu');
        hamburger.addEventListener('click', () => {
            mobileMenu.classList.toggle('active');
        });
    </script>
</body>
</html>